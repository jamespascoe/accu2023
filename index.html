<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Advanced C++20 Coroutines</title>

    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico?">

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/league.css" id="theme">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/github.css" id="highlight-theme">

  </head>
  <body>
    <div class="reveal">
      <div class="slides">

        <!--
        <section id="Title-Slide"
                 data-state="hideControls"
                 data-menu-title="Title Slide"
                 data-background-image="media/title-slide.png"
                 data-background-size="contain">
        </section>
        -->

        <section data-menu-title="Advanced C++20 Coroutines">
          <h2>Advanced C++20 Coroutines</h2>
          <p>
            <small>
              Jim (James) Pascoe<br>
              <a href="http://www.james-pascoe.com">http://www.james-pascoe.com</a><br>
              <a href="mailto:james@james-pascoe.com">james@james-pascoe.com</a><p>

              <a href="http://jamespascoe.github.io/accu2023">http://jamespascoe.github.io/accu2023</a><br>
              <a href="https://github.com/jamespascoe/accu2023-example-code.git">https://github.com/jamespascoe/accu2023-example-code.git</a>
            </small>
        </section>

        <section data-menu-title="Poll: Coroutine Familiarity">
          <span class="fragment"><h3 style="color:yellow">Poll: Coroutine Familiarity ...</span><span class="fragment"> 1 year on</h3></span>
          <p>
            <ol>
              <span class="fragment"><li>I am confident using coroutines</li></span>
              <span class="fragment"><li>I understand coroutines better than a year ago</li></span>
              <span class="fragment"><li>I understand a little more than a year ago</li></span>
              <span class="fragment"><li>I am still just starting to understand coroutines</li></span>
            </ol>
        </section>
        <section>
          <h2>Why this talk?</h2>
          <span class="fragment" style="color:yellow">Lots of good introductory talks ... </span>
          <span class="fragment" style="color:yellow">but, what's next?</span>
          <p>
          <ul>
            <span class="fragment"><li>Advice: when and how to use coroutines</li></span>
            <span class="fragment"><li>Examples: real-world and exemplar code</li></span>
            <span class="fragment"><li>Insight: empirical evaluations</li></span>
            <span class="fragment"><li>Update: what's coming in C++23/26</li></span>
          </ul>
        </section>
        <section>
          <h2>Outline</h2>
          <ul>
            <span class="fragment"><li>Concurrency in Modern C++</li></span>
            <ul>
              <span class="fragment"><li>How C++20 Coroutines fit</span><span class="fragment"> (and work)</li></span>
            </ul>
            <span class="fragment"><li><a href="https://www.bluwireless.com/products/5g-tactical/">Mobile Wireless Networking</a> with Coroutines</li></span>
            <span class="fragment"><li>Code Example: Web Serving with <a href="https://www.boost.org/doc/libs/1_81_0/libs/beast/doc/html/index.html">Boost.Beast</a></li></span>
            <ul>
              <span class="fragment"><li>Synchronous, Asynchronous</li></span>
              <span class="fragment"><li><a href="https://www.boost.org/doc/libs/1_81_0/libs/coroutine2/doc/html/coroutine2/overview.html">Boost.Coroutine2</a>, <a href="https://www.boost.org/doc/libs/1_81_0/libs/beast/example/http/server/awaitable/http_server_awaitable.cpp">Awaitables</a></li></span>
              <span class="fragment"><li>Empirical analysis with <a href="https://httpd.apache.org/docs/2.4/programs/ab.html">Apache bench</a> (ab)</li></span>
            </ul>
            <span class="fragment"><li><a href="http://wg21.link/p2502">P2502:</a> std::generator</li></span>
          </ul>
        </section>
        <section>
          <h2><a href="https://github.com/jamespascoe/accu2023-example-code.git">Example Code: Tools & Build</a></h2>
            <ul>
              <span class="fragment"><li>C++ examples all compile with <a href="https://gcc.gnu.org/gcc-12/changes.html">GCC 12.2</a>:</li></span>
              <span class="fragment"><ul><li><a href="https://www.boost.org/doc/libs/1_81_0/libs/beast/doc/html/index.html">Boost Beast 1.81.0</a></li></ul></span>
              <span class="fragment"><li>Lua examples run with <a href="https://www.lua.org/download.html">Lua 5.4.4</a>:</li></span>
              <span class="fragment"><ul><li>Requires <code>luaposix</code> and <code>luasocket</code></li></ul></span>
              <span class="fragment"><ul><li><code>sudo luarocks install luaposix</code></li></ul></span>
              <span class="fragment"><ul><li><code>sudo luarocks install luasocket</code></li></ul></span>
              <span class="fragment"><li>Tested on Linux Mint 19 and Mac OS X (<font size="6">Mojave</font>, <font size="6">Big Sur</font>)</li></span>
            </ul>
        </section>

      <section>
        <section data-background-video="media/BWT_Intermission.mp4" data-background-video-loop=true>
          <h1>Concurrency and Coroutines</h1>
        </section>


        <!--
          Concurrency vs. Parallelism

          Concurrency
            harnessing latency to do useful work elsewhere
            can be pre-emptive (OS decides when to swicth) or Co-operative (programmer decides)
            Coroutines fit here

          Parallelism
            doing multiple things at the same instant
            often implies hardware support
            multiple cores mean that you can run multiple threads
            multiple issue pipelines in CPUs provide instruction level paralism

        <--

        <!--


          Concurrency recap.

          Needs to culminate in mobile mesh example.

        -->

        <!--

          Import Coroutine Section from last year
            Add new mermaid diagrams
            Add mention to HALO optimisation wg21.link/p0981r0
            Generally improve it

        -->

        <section data-menu-title="Blu Wireless Mobile Mesh"
                 data-state="hideControls",
                 data-background-video="media/BWT_MobileMesh.mp4"
                 id="video">
        </section>

        <section>
          <h2>Coroutines</h2>
          <span class="fragment" style="color:yellow">Coroutines are subroutines </span>
          <span class="fragment" style="color:yellow">with enhanced semantics</span><p>
          <ul>
            <span class="fragment"><li>Invoked by a caller </span>
            <span class="fragment">(and return to a caller) ...</li></span>
            <span class="fragment"><li>Can suspend execution</li></span>
            <span class="fragment"><li>Can resume execution (at a later time)</li></span>
          </ul>
          <aside class="notes">
          When I am thinking about coroutines, I quite like the term subroutine because a subroutine can be either a function or a coroutine.
          So, the key benefit of a coroutine is its suspension / resumption semantics. A function is called from a caller and then returns.
          A coroutine is initially called from a caller, but can suspend its execution (at which point control is returned to the caller) and
          then 'later' is resumed (typically after an asynchronous event or the completion of some computation).
          </aside>
        </section>

        <section>
          <h2>Benefits</h2>
          <span class="fragment" style="color:yellow">Write asynchronous code ...</span><br>
          <span class="fragment" style="color:yellow">with the readability of synchronous code</span><p>
          <ul>
            <span class="fragment"><li>Useful for networking</li></span>
            <span class="fragment"><li>Lots of blocking operations (connect, send, receive)</li></span>
            <span class="fragment"><li>Multi-threading (send and receive threads)</li></span>
            <span class="fragment"><li>Asynchronous operations mean callbacks</li></span>
            <span class="fragment"><li>Control flow fragments</li></span>
          </ul>
        </section>

        <section>
          <h2>Coroutines</h2>
          <span class="fragment" style="color:yellow">Coroutines are subroutines </span>
          <span class="fragment" style="color:yellow">with enhanced semantics</span><p>
          <ul>
            <span class="fragment"><li>Invoked by a caller </span>
            <span class="fragment">(and return to a caller) ...</li></span>
            <span class="fragment"><li>Can suspend execution</li></span>
            <span class="fragment"><li>Can resume execution (at a later time)</li></span>
          </ul>
          <aside class="notes">
          When I am thinking about coroutines, I quite like the term subroutine because a subroutine can be either a function or a coroutine.
          So, the key benefit of a coroutine is its suspension / resumption semantics. A function is called from a caller and then returns.
          A coroutine is initially called from a caller, but can suspend its execution (at which point control is returned to the caller) and
          then 'later' is resumed (typically after an asynchronous event or the completion of some computation).
          </aside>
        </section>

        <section>
          <h2>Benefits</h2>
          <span class="fragment" style="color:yellow">Write asynchronous code ...</span><br>
          <span class="fragment" style="color:yellow">with the readability of synchronous code</span><p>
          <ul>
            <span class="fragment"><li>Useful for networking</li></span>
            <span class="fragment"><li>Lots of blocking operations (connect, send, receive)</li></span>
            <span class="fragment"><li>Multi-threading (send and receive threads)</li></span>
            <span class="fragment"><li>Asynchronous operations mean callbacks</li></span>
            <span class="fragment"><li>Control flow fragments</li></span>
          </ul>
        </section>

        <section data-menu-title="Coroutines in C++20">
          <h2><a href="https://en.cppreference.com/w/cpp/language/coroutines">Coroutine Support in C++20</a></h2>
            <ul>
              <span class="fragment"><li>Three new keywords: <a href="https://en.cppreference.com/w/cpp/language/coroutines#co_await">co_await</a>, <a href="https://en.cppreference.com/w/cpp/language/coroutines#co_yield">co_yield</a>, <a href="https://en.cppreference.com/w/cpp/language/coroutines#co_return">co_return</a></li></span>
              <span class="fragment"><li>New types:</li></span>
              <ul>
                <span class="fragment"><li><a href="https://en.cppreference.com/w/cpp/coroutine/coroutine_handle"><code>coroutine_handle&ltP&gt</code></a></li></span>
                <span class="fragment"><li><a href="https://en.cppreference.com/w/cpp/coroutine/coroutine_traits"><code>coroutine_traits&ltTs...&gt</code></a></li></span>
              </ul>
              <span class="fragment"><li>Trivial awaitables:</li></span>
              <ul>
                <span class="fragment"><li><a href="https://en.cppreference.com/w/cpp/coroutine/suspend_always"><code>std::suspend_always</code></a></li></span>
                <span class="fragment"><li><a href="https://en.cppreference.com/w/cpp/coroutine/suspend_never"><code>std::suspend_never</code></a></li></span>
              </ul>
            </ul>
          <aside class="notes">
          What do we actually get in C++20? Three new keywords and for me, really the star-of-the-show is co_await because
          co_await suspends execution of a coroutine and returns control to the caller. co_yield, yields a value from a coroutine and
          then suspends. So if you think of a generator, co_yield produces a value and then suspends for the next iteration. co_return
          goes one step further by completing execution of the coroutine (and returns a value).
          <p>
          coroutine_handles are pointers to coroutine state and are used to resume and destroy coroutines. coroutine state is a fairly deep concept.
          Usually allocated on the heap (although I think there are some compilers will elide it to the caller's stack) and contains the coroutine's
          promise, parameters, as well as its volatile state, so values of local variables, resumption point etc. Basically anything that is needed
          to resume that coroutine at a later point. And that resumption may take place on some other thread.
          <p>
          coroutine_traits gives you the promise type from a coroutine's return type and its parameters. And then we have two trivial awaitables
          called suspend_always and suspend_never and these are useful in a number of places, typically for controlling whether we want a coroutine
          to begin lazily or eagerly.
          </aside>
        </section>

        <section id="key-references">
          <h2>Key References</h2>
            <ul>
              <span class="fragment"><li><a href="https://lewissbaker.github.io/">Lewis Baker's</a> blog posts:</li></span>
              <span class="fragment"><ul><li><a href="https://lewissbaker.github.io/2017/09/25/coroutine-theory">Coroutine Theory</a></li></ul></span>
              <span class="fragment"><ul><li><a href="https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await">Understanding operator co_await</a></li></ul></span>
              <span class="fragment"><ul><li><a href="https://lewissbaker.github.io/2018/09/05/understanding-the-promise-type">Understanding the promise type</a></li></ul></span>
              <span class="fragment"><ul><li><a href="https://lewissbaker.github.io/2020/05/11/understanding_symmetric_transfer">Understanding Symmetric Transfer</a></li></ul></span>
              <span class="fragment"><li><a href="https://www.scs.stanford.edu/~dm">Dave Mazi√®re's</a> blog post:</li></span>
              <span class="fragment"><ul><li><a href="https://www.scs.stanford.edu/~dm/blog/c++-coroutines.html">My tutorial and take on C++20 coroutines</a></li></ul></span>
              <span class="fragment"><li><a href="https://wg21.link/n4775">Gor Nishanov:</a></li></span>
              <span class="fragment"><ul><li><a href="https://wg21.link/n4775">C++ Extensions for Coroutines (N4775)</a></li></ul></span>
            </ul>
        </section>

        <section>
          <h2><a href="https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await">Awaitable Type</a></h2>
          <ul>
            <span class="fragment"><li>Supports the <code>co_await</code> operator</li></span>
            <span class="fragment"><li>Controls the semantics of an <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4775.pdf">await-expression</a></li></span>
            <span class="fragment"><li>Informs the compiler how to obtain the <a href="https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await">awaiter</a></li></span>
          </ul>

          <span class="fragment"><pre><code class="c++" data-trim data-line-numbers="">
co_await async_write(..., use_awaitable);
          </span></code></pre>

          <aside class="notes">
          [after bullets 1-4]

          Ok, so why the distinction? I.e. why do we have the concept of an Awaitable type and an Awaiter?
          So, an awaitable type is a type that supports co_await. But, whether or not co_await can be applied
          directly to a type depends on the context in which the co_await expression appears. The promise type
          can alter the semantics of the co_await expression through an 'await_transform' method and I've got a slide
          coming up on that shortly.

          By contrast the awaiter type allows the user to specify the coroutine's behaviour at specific points in
          the suspension and resumption process. Lets take a look at the awaiter.
          </aside>
        </section>

        <section>
          <h2><a href="https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await">Awaiter Type</a></h2>
          <ul>
            <span class="fragment"><li>Defines suspend and resume behaviour</li></span>
            <span class="fragment"><li><code><a href="https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await">await_ready</a></code>: is suspend required?</li></span>
            <span class="fragment"><li><code><a href="https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await">await_suspend</a></code>: schedule resume</li></span>
            <span class="fragment"><li><code><a href="https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await">await_resume</a></code>: <code>co_await</code> return result</li></span>
            <span class="fragment"><li>Can be the same as the <a href="https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await">awaitable type</a></li></span>
          </ul>
          <aside class="notes">
          The await_ready method allows you to avoid the cost of suspending if you know that the operation is going to complete synchronously.
          <p>
          By contrast, the key purpose of the await_suspend method is to schedule the coroutine for resumption. In particular, once the await
          suspend method is called, the coroutine is suspended, so you are free to pass the coroutine handle to an executor so that the coroutine
          can be resumed later.
          <p>
          And then when the coroutine is resumed, the await_resume method is called to obtain the result of the operation and that is what is
          returned in the coroutine.
          </aside>
        </section>

        <section>
          <h2>Coroutine Return Type</h2>
          <ul>
            <span class="fragment"><li>Declares the promise type to the compiler</li></span>
            <span class="fragment"><ul><li>Using <code>coroutine_traits</code></li></ul></span>
            <span class="fragment"><li>E.g. '<code>task&ltT&gt</code>' or '<code>generator&ltT&gt</code>'</li></span>
            <span class="fragment"><li><a href="https://github.com/lewissbaker/cppcoro">CppCoro</a> defines several return types</li></span>
            <span class="fragment"><li>Referred to as a 'future' in some <a href="http://wg21.link/">WG21</a> papers</li></span>
            <span class="fragment"><li>Not to be confused with <code>std::future</code></li></span>
          </ul>
        </section>

        <section>
          <h2><a href="https://lewissbaker.github.io/2018/09/05/understanding-the-promise-type">Promise Type</a></h2>
          <ul>
            <span class="fragment"><li>Controls the coroutine's behaviour</li></span>
            <span class="fragment"><ul><li>... example coming up</li></ul></span>
            <span class="fragment"><li>Implements methods that are called at specific points during the execution of the coroutine</li></span>
            <span class="fragment"><li>Conveys coroutine result (or exception)</li></span>
            <span class="fragment"><li>Again - not to be confused with <code>std::promise</code></li></span>
          </ul>
        </section>

        <section>
          <h2><a href="https://lewissbaker.github.io/2018/09/05/understanding-the-promise-type">Customising Co_Await</a></h2>
          <ul>
            <span class="fragment"><li>The <code>await_transform</code> method:</li></span>
            <span class="fragment"><ul><li>Defined in the <code>promise_type</code></li></ul></span>
            <span class="fragment"><ul><li>Enables types that are not awaitable</li></ul></span>
            <span class="fragment"><ul><li>Disables <code>co_await</code> on certain types</li></ul></span>
            <span class="fragment"><ul><li>Modify the behaviour of awaitable values</li></ul></span>
            <span class="fragment"><li>Also possible to customise <code>co_yield</code></li></span>
            <span class="fragment"><li>See Lewis Baker's excellent <a href="https://lewissbaker.github.io/2018/09/05/understanding-the-promise-type">Blog Post</a> for details</li></span>
          </ul>
        </section>

        <section>
          <h2><a href="https://en.cppreference.com/w/cpp/coroutine/coroutine_handle">Coroutine Handles</a></h2>
          <ul>
            <span class="fragment"><li>Handle to a coroutine frame on the heap</li></span>
            <span class="fragment"><li>Means through which coroutines are resumed</li></span>
            <span class="fragment"><li>Also provide access to the promise type</li></span>
            <span class="fragment"><li>Non-owning - have to be destroyed explicitly</li></span>
            <span class="fragment"><ul><li>Often through RAII in the coroutine return type</li></ul></span>
          </ul>
          <aside class="notes">
            Bit like a C pointer
          </aside>
        </section>
      </section>

        <!--

          Empirical study

          How do we study Coroutines Empirically?

          Coroutine example - Boost.beast
            Synchronous, Asycnhronous, Boost.Coroutine2 and awaitables
            apache bench

          Give data

            perf

        -->

        <!--

          Section on 'the future'

          P2502
          libunifex
          Std::exec
          Conclusions
          Questions

        -->

      <section>

        <section>
          <h2>Questions?</h2>
          <p><p>
          <a href="http://www.james-pascoe.com">http://www.james-pascoe.com</a><br>
          <a href="mailto:james@james-pascoe.com">james@james-pascoe.com</a><p>

          <a href="http://jamespascoe.github.io/accu2023">http://jamespascoe.github.io/accu2023</a><br>
          <a href="https://github.com/jamespascoe/accu2023-example-code.git"><font size="6">https://github.com/jamespascoe/accu2023-example-code.git</font></a>
        </section>

<!--
  Bristol and Bath Meetup
-->

        </section>
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script src="plugin/menu/menu.js"></script>
    <script src="plugin/chart/Chart.min.js"></script>
    <script src="plugin/chart/plugin.js"></script>
    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      Reveal.initialize({
        hash: true,
        controls: true,
        totalTime: 5400,
        hideInactiveCursor: true,
        hideCursorTime: 2000,
        hideAddressBar: true,
        preloadIframes: true,
        progress: false,
        touch: true,
        keyboard: {
          67: () => { /* Keycode for the letter 'c' i.e. 'controls' */
            var currentSlide = Reveal.getCurrentSlide();
            var currentVideo = currentSlide.getElementsByTagName('video')[0];
            if (currentVideo) {
              /* Toggle video controls on/off */
              currentVideo.controls = !currentVideo.controls
            }
          },
          32: () => { /* Keycode for spacebar */
            var currentSlide = Reveal.getCurrentSlide();
            var currentVideo = currentSlide.getElementsByTagName('video')[0];
            if (currentVideo) {
              /* Pause/resume video when the spacebar is pressed */
              if (currentVideo.paused == true) currentVideo.play();
              else currentVideo.pause();
            }
            else {
              /* Advance to next slide if no video (default Reveal behaviour) */
              Reveal.next();
            }
          }
        },
        chart: {
          defaults: {
            global: {
              title: { fontColor: "#FFF" },
              legend: {
                position: "bottom",
                labels: { fontColor: "#FFF" },
              },
              tooltips: {
                labels: { fontColor: "#FFF" },
              },
            },
            scale: {
              scaleLabel: { fontColor: "#FFF" },
              gridLines: { color: "#FFF", zeroLineColor: "#FFF" },
              ticks: { fontColor: "#FFF" },
            }
          },
          bar: { backgroundColor: [ "rgba(20,220,220,.8)" , "rgba(220,120,120,.8)", "rgba(20,120,220,.8)", "rgba(255, 159, 64, .8)","rgba(255, 205, 86, .8)", "rgba(153, 102, 255, .8)" ]},
        },
        menu: {
          themes: true,
          delayInit: true
        },
        pdfSeparateFragments: false,
        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealMenu, RevealChart ]
      });

      Reveal.addEventListener('hideControls', function() {
        Reveal.configure({controls: false});
      }, false );

      Reveal.addEventListener('slidechanged', function() {
        /* Ensure that the Reveal controls and Menu are available on
         * all slides other than the 'Title-Slide'.
         */
        slide_id = Reveal.getCurrentSlide().getAttribute("id");

        if (slide_id !== "Title-Slide") {
          config = Reveal.getConfig();
          if (config["controls"] !== true) {
            Reveal.configure({controls: true});
          }

          menu = Reveal.getPlugin("menu");
          if (!menu.isMenuInitialised()) {
            menu.initialiseMenu();
          }
        }
      }, false );

      Reveal.addEventListener('increasePlaybackSpeed', function() {
        var currentSlide = Reveal.getCurrentSlide();
        var currentVideo = currentSlide.getElementsByTagName('video')[0];
        if (currentVideo) {
          currentVideo.playbackRate = 2.0;
        }
      }, false );
   </script>
  </body>
</html>
