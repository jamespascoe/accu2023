<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Advanced C++20 Coroutines</title>

    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico?">

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/league.css" id="theme">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/github.css" id="highlight-theme">

  </head>
  <body>
    <div class="reveal">
      <div class="slides">

        <!--
        <section id="Title-Slide"
                 data-state="hideControls"
                 data-menu-title="Title Slide"
                 data-background-image="media/title-slide.png"
                 data-background-size="contain">
        </section>
        -->

        <section data-menu-title="Advanced C++20 Coroutines">
          <h2>Advanced C++20 Coroutines</h2>
          <p>
            <small>
              Jim (James) Pascoe<br>
              <a href="http://www.james-pascoe.com">http://www.james-pascoe.com</a><br>
              <a href="mailto:james@james-pascoe.com">james@james-pascoe.com</a><p>

              <a href="http://jamespascoe.github.io/accu2023">http://jamespascoe.github.io/accu2023</a><br>
              <a href="https://github.com/jamespascoe/accu2023-example-code.git">https://github.com/jamespascoe/accu2023-example-code.git</a>
            </small>
        </section>

        <section data-menu-title="What Else Do We Need?">
          <span class="fragment"><h3 style="color:yellow">Coroutines ...</span><span class="fragment"> What Else Do We Need?</h3></span>
          <p>
            <ol>
              <span class="fragment"><li>Fit within the wider concurrency framework</li></span>
              <span class="fragment"><li>More examples (real-world and learning)</li></span>
              <span class="fragment"><li>Empirical measurements</li></span>
              <span class="fragment"><li>Library support and the future</li></span>
            </ol>
            <aside class="notes">
            Coroutines still feel a bit ephemeral. Deeply technical, still quite difficult to know when
            to use them. I want to address this in this talk.
            </aside>
        </section>

        <section>
          <h2>Outline</h2>
          <ul>
            <span class="fragment"><li>Concurrency in Modern C++</li></span>
            <ul>
              <span class="fragment"><li>How C++20 Coroutines fit</span><span class="fragment"> (and work)</li></span>
            </ul>
            <span class="fragment"><li><a href="https://www.bluwireless.com/products/5g-tactical/">Mobile Wireless Networking</a> with Coroutines</li></span>
            <span class="fragment"><li>C++20 Example: Web Serving with <a href="https://www.boost.org/doc/libs/1_81_0/libs/beast/doc/html/index.html">Boost.Beast</a></li></span>
            <ul>
              <span class="fragment"><li>Synchronous, Asynchronous</li></span>
              <span class="fragment"><li><a href="https://www.boost.org/doc/libs/1_81_0/libs/coroutine2/doc/html/coroutine2/overview.html">Boost.Coroutine</a>, <a href="https://www.boost.org/doc/libs/1_81_0/libs/beast/example/http/server/awaitable/http_server_awaitable.cpp">Awaitables</a></li></span>
              <span class="fragment"><li>Empirical analysis with <a href="https://httpd.apache.org/docs/2.4/programs/ab.html">Apache bench</a> (ab)</li></span>
            </ul>
            <span class="fragment"><li><a href="http://wg21.link/p2502">P2502:</a> std::generator</li></span>
          </ul>
        </section>

        <section>
          <h2><a href="https://github.com/jamespascoe/accu2023-example-code.git">Example Code: Tools & Build</a></h2>
            <ul>
              <span class="fragment"><li>C++ examples all compile with <a href="https://gcc.gnu.org/gcc-12/changes.html">GCC 12.2</a>:</li></span>
              <span class="fragment"><ul><li><a href="https://www.boost.org/doc/libs/1_81_0/libs/beast/doc/html/index.html">Boost Beast 1.81.0</a></li></ul></span>
              <span class="fragment"><li>Lua examples run with <a href="https://www.lua.org/download.html">Lua 5.4.4</a>:</li></span>
              <span class="fragment"><ul><li>Requires <code>luaposix</code> and <code>luasocket</code></li></ul></span>
              <span class="fragment"><ul><li><code>sudo luarocks install luaposix</code></li></ul></span>
              <span class="fragment"><ul><li><code>sudo luarocks install luasocket</code></li></ul></span>
              <span class="fragment"><li>Tested on Linux Mint 19 and Mac OS X (<font size="6">Mojave</font>, <font size="6">Big Sur</font>)</li></span>
            </ul>
        </section>

      <section>
        <section data-menu-title="Concurrency Back-to-Basics" data-background-video="media/BWT_Intermission.mp4" data-background-video-loop=true>
          <h1>Concurrency<br>Back-to-Basics</h1>
        </section>

        <section>
          <h2><a href=https://www.gnu.org/software/pth/pth-manual.html#threading_background">Concurrency vs. Parallelism</a></h2>
            <ul>
              <span class="fragment" style="color:yellow"><li>Concurrency exists when:</li></span>
              <ul>
                <span class="fragment"><li>multiple items of work are 'in progress'</li></span>
                <span class="fragment"><li>e.g. processes, threads or coroutines</li></span>
              </ul><br>
              <span class="fragment" style="color:yellow"><li>Parallelism exists when:</li></span>
              <ul>
                <span class="fragment"><li>multiple items of work execute simultaneously</li></span>
                <span class="fragment"><li>e.g. threads running on separate CPU cores</li></span>
              </ul>
            </ul>
            <aside class="notes">
            Concurrency exists when at least two threads are 'in progress' at the same time.
            Parallelism arises when at least two threads are executing simultaneously.

            I think it was Arthur O'Dwyer at CppCon 2020 who said that broadly speaking, parallelism in the context of Computer Science
            generally requires some form of hardware. So, for example, my MAC is a quad core Intel i7 that's based on the Haswell
            architecture. So this means it can run four threads, in parallel, at the same instant. If we go one level deeper we can
            see that the Haswell microarchitecture is a dual-threaded, out-of-order microprocessor that is capable of decoding 5
            instructions, issuing 4 fused uops (micro operations) and dispatching 8 uops on each cycle (and its clocked at 4GHz)..
            </aside>
            </aside>
        </section>

        <section data-menu-title="Concurrency">
          <img class="stretch" data-src="media/concurrency.png" style="background:none; border:none; box-shadow:none;">
        </section>

        <section data-menu-title="Parallelism">
          <img class="stretch" data-src="media/parallelism.png" style="background:none; border:none; box-shadow:none;">
        </section>

        <section>
          <h2><a href="https://www.boost.org/doc/libs/1_81_0/libs/fiber/doc/html/fiber/overview.html">Taxonomy</a></h2>
            <ol>
              <span class="fragment"><li>Multiple processes run on a single computer</li></span>
              <span class="fragment"><li>Multiple threads run within a single process</li></span>
              <span class="fragment"><li>Multiple coroutines run within a single thread</li></span>
            </ol>
            <p>
            <span class="fragment" style="color:yellow">Note: don't confuse coroutines with <a href="http://wg21.link/n4024">Fibers</a><br>
            (see <a href="https://www.boost.org/doc/libs/1_81_0/libs/fiber/doc/html/fiber/overview.html">Boost.Fiber</a>) and <a href="https://en.wikipedia.org/wiki/Green_thread">Green Threads</a></span>
            <aside class="notes">
            A note of caution with the terms 'Coroutine', 'Fibers' and 'Green Threads'. They are sometimes used inter-changeably and
            there are differences. My personal view is that fibers can be implemented using coroutines (this is exactly what Lua
            does and Boost.Fiber is built on Boost.Coroutine), but they are not equivalent. For example, coroutines that are generators
            are clearly not fibers. Coroutines provide enhanced control flow semantics, whereas, fibers give you a co-operatively scheduled
            light-weight threading model (that resembles OS threads).

            Green Threads are threads that are scheduled by a runtime library or a virtual machine (so not an OS thread). The name actually
            comes from the early days of Java - it was a co-operative threading model in Java 1.1, that was abandoned in 1.3 (back in the days
            of the JDK 1.x for anyone that remembers it).
            </aside>
        </section>

        <section>
          <h2>Processes</h2>
            <ul>
              <span class="fragment"><li></li></span>
            </ul>
            <aside class="notes">
            </aside>
        </section>

        <!-- PICTURE -->

        <section>
          <h2>Threads</h2>
            <ul>
              <span class="fragment"><li></li></span>
            </ul>
            <aside class="notes">
            </aside>
        </section>

        <!-- PICTURE -->

        <section>
          <h2>Coroutines (Fibers)</h2>
            <ul>
              <span class="fragment"><li></li></span>
            </ul>
            <aside class="notes">
            </aside>
        </section>

        <!-- PICTURE -->

<!--

2. Processes

The most obvious form of concurrency
Heavy-weight (includes lots of state)
Context switch is high cost
Context switch occurs when either a blocking system call, or a pre-emptive time slice has expired
Critical sections must be protected with locks, mutexs etc.

Pre-emptive scheduler (OS) triggers a context switch either because a process is blocked (e.g. on a mutex), or because a time-slice has expired.

diagram

3. Threads

Lighter weight - substantially less state
Partitions a process so that useful work can be done in other parts when one part is blocked
Give details of the thread scheduler

Give C++ timeline

diagram

Reentrancy vs. thread safety

4. Coroutines

Allow 

diagram (mermaid)

Add mention to HALO optimisation wg21.link/p0981r0

-->

      </section>
      <section>

        <section data-background-video="media/BWT_Intermission.mp4" data-background-video-loop=true>
          <h1>Coroutines in the Real-World</h1>
        </section>

        <section>
          <h2><a href="http://bluwireless.com/applications/defence-and-perimeter-security/">Blu Wireless:</a> Mobile Mesh</h2>
          <ul>
            <span class="fragment"><li>IP networking over 5G mmWave (60 GHz) modems</li></span>
            <span class="fragment"><ul><li>802.11ad MAC + PHY (Hydra) + software</li></ul></span>
            <span class="fragment"><li>High-bandwidth, low latency mobile Internet</li></span>
            <span class="fragment"><ul><li>Up to 3Gbps wireless links (up to 4km)</ul></span>
            <span class="fragment"><li>Embedded quad-core ARMv8 NPUs</li></span>
          </ul>
          <aside class="notes">

          </aside>
        </section>

        <section data-menu-title="Blu Wireless Mobile Mesh"
                 data-state="hideControls",
                 data-background-video="media/BWT_MobileMesh.mp4"
                 id="video">
        </section>

        <section data-menu-title="Blu Wireless Devices">
          <img class="stretch" data-src="media/5G-tactical-comms.png" style="background:none; border:none; box-shadow:none;">
        </section>

        <section>
          <h2>How Does it Work?</h2>
          <ul>
            <span class="fragment"><li>Implemented using Coroutines</li></span>
            <ul>
              <span class="fragment"><li>Combination of Modern C++ (17/20) and Lua</li></span>
            </ul>
            <span class="fragment"><li>Lots of asynchronous operations</li></span>
            <ul>
              <span class="fragment"><li>Scan, Connect, Disconnect</li></span>
              <span class="fragment"><li>Around 40 high-level primitives</li></span>
            </ul>
            <span class="fragment"><li>Groups of coroutines operate in threads</li></span>
            <span class="fragment"><li>Do useful work during latency windows</li></span>
            <span class="fragment"><li>No race-conditions, issues with data sharing</li></span>
          </ul>
          <aside class="notes">
          Why am I telling you this?
          </aside>
        </section>

        <!--
 
          Why am I showing this?
            MCM is written in modern C++
            We are going to write a small Mesh simulator

            LUA/SWIG example:

              3 coroutines:
                - connector (responsible for maitaining a connection to the mesh)
                  - 'scans' i.e. tries to connect (via a socket) to other nodes. Probably best to just wait some time and return a 'PCP'.
                  - 'connects' i.e. makes the connection. Typically would authenticate/agree encryption.

                - event_monitor
                  - randomly returns 'disconnected' i.e. mesh behaviour polls event_monitor and after
                    a random period (e.g. between 1 and 10 seconds), gets a return value which says 'disconnected'.
                    The Mesh behaviour (at this point), sets a flag to say 'not connected' which triggers the
                    'connector' coroutine to 'scan' (i.e. wait for a random interval and return a result) and
                    'connect'.

                - dispatcher
                  - as before

            Mesh Behaviour:
              Implements coroutines

            C++ actions:
              Implement scan
              Implement connect
              Implement event_monitor (provides 'IsConnected' method, which after a period 

        -->

      </section>
      <section>

        <section>
          <h2>C++20 Coroutines</h2>
          <span class="fragment" style="color:yellow">Coroutines are subroutines </span>
          <span class="fragment" style="color:yellow">with enhanced semantics</span><p>
          <ul>
            <span class="fragment"><li>Invoked by a caller </span>
            <span class="fragment">(and return to a caller) ...</li></span>
            <span class="fragment"><li>Can suspend execution</li></span>
            <span class="fragment"><li>Can resume execution (at a later time)</li></span>
          </ul>
          <aside class="notes">
          When I am thinking about coroutines, I quite like the term subroutine because a subroutine can be either a function or a coroutine.
          So, the key benefit of a coroutine is its suspension / resumption semantics. A function is called from a caller and then returns.
          A coroutine is initially called from a caller, but can suspend its execution (at which point control is returned to the caller) and
          then 'later' is resumed (typically after an asynchronous event or the completion of some computation).
          </aside>
        </section>

        <section>
          <h2>Benefits</h2>
          <span class="fragment" style="color:yellow">Write asynchronous code ...</span><br>
          <span class="fragment" style="color:yellow">with the readability of synchronous code</span><p>
          <ul>
            <span class="fragment"><li>Useful for networking</li></span>
            <span class="fragment"><li>Lots of blocking operations (connect, send, receive)</li></span>
            <span class="fragment"><li>Multi-threading (send and receive threads)</li></span>
            <span class="fragment"><li>Asynchronous operations mean callbacks</li></span>
            <span class="fragment"><li>Control flow fragments</li></span>
          </ul>
        </section>

        <section>
          <h2>Coroutines</h2>
          <span class="fragment" style="color:yellow">Coroutines are subroutines </span>
          <span class="fragment" style="color:yellow">with enhanced semantics</span><p>
          <ul>
            <span class="fragment"><li>Invoked by a caller </span>
            <span class="fragment">(and return to a caller) ...</li></span>
            <span class="fragment"><li>Can suspend execution</li></span>
            <span class="fragment"><li>Can resume execution (at a later time)</li></span>
          </ul>
          <aside class="notes">
          When I am thinking about coroutines, I quite like the term subroutine because a subroutine can be either a function or a coroutine.
          So, the key benefit of a coroutine is its suspension / resumption semantics. A function is called from a caller and then returns.
          A coroutine is initially called from a caller, but can suspend its execution (at which point control is returned to the caller) and
          then 'later' is resumed (typically after an asynchronous event or the completion of some computation).
          </aside>
        </section>

        <section>
          <h2>Benefits</h2>
          <span class="fragment" style="color:yellow">Write asynchronous code ...</span><br>
          <span class="fragment" style="color:yellow">with the readability of synchronous code</span><p>
          <ul>
            <span class="fragment"><li>Useful for networking</li></span>
            <span class="fragment"><li>Lots of blocking operations (connect, send, receive)</li></span>
            <span class="fragment"><li>Multi-threading (send and receive threads)</li></span>
            <span class="fragment"><li>Asynchronous operations mean callbacks</li></span>
            <span class="fragment"><li>Control flow fragments</li></span>
          </ul>
        </section>

        <section data-menu-title="Coroutines in C++20">
          <h2><a href="https://en.cppreference.com/w/cpp/language/coroutines">Coroutine Support in C++20</a></h2>
            <ul>
              <span class="fragment"><li>Three new keywords: <a href="https://en.cppreference.com/w/cpp/language/coroutines#co_await">co_await</a>, <a href="https://en.cppreference.com/w/cpp/language/coroutines#co_yield">co_yield</a>, <a href="https://en.cppreference.com/w/cpp/language/coroutines#co_return">co_return</a></li></span>
              <span class="fragment"><li>New types:</li></span>
              <ul>
                <span class="fragment"><li><a href="https://en.cppreference.com/w/cpp/coroutine/coroutine_handle"><code>coroutine_handle&ltP&gt</code></a></li></span>
                <span class="fragment"><li><a href="https://en.cppreference.com/w/cpp/coroutine/coroutine_traits"><code>coroutine_traits&ltTs...&gt</code></a></li></span>
              </ul>
              <span class="fragment"><li>Trivial awaitables:</li></span>
              <ul>
                <span class="fragment"><li><a href="https://en.cppreference.com/w/cpp/coroutine/suspend_always"><code>std::suspend_always</code></a></li></span>
                <span class="fragment"><li><a href="https://en.cppreference.com/w/cpp/coroutine/suspend_never"><code>std::suspend_never</code></a></li></span>
              </ul>
            </ul>
          <aside class="notes">
          What do we actually get in C++20? Three new keywords and for me, really the star-of-the-show is co_await because
          co_await suspends execution of a coroutine and returns control to the caller. co_yield, yields a value from a coroutine and
          then suspends. So if you think of a generator, co_yield produces a value and then suspends for the next iteration. co_return
          goes one step further by completing execution of the coroutine (and returns a value).
          <p>
          coroutine_handles are pointers to coroutine state and are used to resume and destroy coroutines. coroutine state is a fairly deep concept.
          Usually allocated on the heap (although I think there are some compilers will elide it to the caller's stack) and contains the coroutine's
          promise, parameters, as well as its volatile state, so values of local variables, resumption point etc. Basically anything that is needed
          to resume that coroutine at a later point. And that resumption may take place on some other thread.
          <p>
          coroutine_traits gives you the promise type from a coroutine's return type and its parameters. And then we have two trivial awaitables
          called suspend_always and suspend_never and these are useful in a number of places, typically for controlling whether we want a coroutine
          to begin lazily or eagerly.
          </aside>
        </section>

        <section id="key-references">
          <h2>Key References</h2>
            <ul>
              <span class="fragment"><li><a href="https://lewissbaker.github.io/">Lewis Baker's</a> blog posts:</li></span>
              <span class="fragment"><ul><li><a href="https://lewissbaker.github.io/2017/09/25/coroutine-theory">Coroutine Theory</a></li></ul></span>
              <span class="fragment"><ul><li><a href="https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await">Understanding operator co_await</a></li></ul></span>
              <span class="fragment"><ul><li><a href="https://lewissbaker.github.io/2018/09/05/understanding-the-promise-type">Understanding the promise type</a></li></ul></span>
              <span class="fragment"><ul><li><a href="https://lewissbaker.github.io/2020/05/11/understanding_symmetric_transfer">Understanding Symmetric Transfer</a></li></ul></span>
              <span class="fragment"><li><a href="https://www.scs.stanford.edu/~dm">Dave Mazi√®re's</a> blog post:</li></span>
              <span class="fragment"><ul><li><a href="https://www.scs.stanford.edu/~dm/blog/c++-coroutines.html">My tutorial and take on C++20 coroutines</a></li></ul></span>
              <span class="fragment"><li><a href="https://wg21.link/n4775">Gor Nishanov:</a></li></span>
              <span class="fragment"><ul><li><a href="https://wg21.link/n4775">C++ Extensions for Coroutines (N4775)</a></li></ul></span>
            </ul>
        </section>

        <section>
          <h2><a href="https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await">Awaitable Type</a></h2>
          <ul>
            <span class="fragment"><li>Supports the <code>co_await</code> operator</li></span>
            <span class="fragment"><li>Controls the semantics of an <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4775.pdf">await-expression</a></li></span>
            <span class="fragment"><li>Informs the compiler how to obtain the <a href="https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await">awaiter</a></li></span>
          </ul>

          <span class="fragment"><pre><code class="c++" data-trim data-line-numbers="">
co_await async_write(..., use_awaitable);
          </span></code></pre>

          <aside class="notes">
          [after bullets 1-4]

          Ok, so why the distinction? I.e. why do we have the concept of an Awaitable type and an Awaiter?
          So, an awaitable type is a type that supports co_await. But, whether or not co_await can be applied
          directly to a type depends on the context in which the co_await expression appears. The promise type
          can alter the semantics of the co_await expression through an 'await_transform' method and I've got a slide
          coming up on that shortly.

          By contrast the awaiter type allows the user to specify the coroutine's behaviour at specific points in
          the suspension and resumption process. Lets take a look at the awaiter.
          </aside>
        </section>

        <section>
          <h2><a href="https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await">Awaiter Type</a></h2>
          <ul>
            <span class="fragment"><li>Defines suspend and resume behaviour</li></span>
            <span class="fragment"><li><code><a href="https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await">await_ready</a></code>: is suspend required?</li></span>
            <span class="fragment"><li><code><a href="https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await">await_suspend</a></code>: schedule resume</li></span>
            <span class="fragment"><li><code><a href="https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await">await_resume</a></code>: <code>co_await</code> return result</li></span>
            <span class="fragment"><li>Can be the same as the <a href="https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await">awaitable type</a></li></span>
          </ul>
          <aside class="notes">
          The await_ready method allows you to avoid the cost of suspending if you know that the operation is going to complete synchronously.
          <p>
          By contrast, the key purpose of the await_suspend method is to schedule the coroutine for resumption. In particular, once the await
          suspend method is called, the coroutine is suspended, so you are free to pass the coroutine handle to an executor so that the coroutine
          can be resumed later.
          <p>
          And then when the coroutine is resumed, the await_resume method is called to obtain the result of the operation and that is what is
          returned in the coroutine.
          </aside>
        </section>

        <section>
          <h2>Coroutine Return Type</h2>
          <ul>
            <span class="fragment"><li>Declares the promise type to the compiler</li></span>
            <span class="fragment"><ul><li>Using <code>coroutine_traits</code></li></ul></span>
            <span class="fragment"><li>E.g. '<code>task&ltT&gt</code>' or '<code>generator&ltT&gt</code>'</li></span>
            <span class="fragment"><li><a href="https://github.com/lewissbaker/cppcoro">CppCoro</a> defines several return types</li></span>
            <span class="fragment"><li>Referred to as a 'future' in some <a href="http://wg21.link/">WG21</a> papers</li></span>
            <span class="fragment"><li>Not to be confused with <code>std::future</code></li></span>
          </ul>
        </section>

        <section>
          <h2><a href="https://lewissbaker.github.io/2018/09/05/understanding-the-promise-type">Promise Type</a></h2>
          <ul>
            <span class="fragment"><li>Controls the coroutine's behaviour</li></span>
            <span class="fragment"><ul><li>... example coming up</li></ul></span>
            <span class="fragment"><li>Implements methods that are called at specific points during the execution of the coroutine</li></span>
            <span class="fragment"><li>Conveys coroutine result (or exception)</li></span>
            <span class="fragment"><li>Again - not to be confused with <code>std::promise</code></li></span>
          </ul>
        </section>

        <section>
          <h2><a href="https://lewissbaker.github.io/2018/09/05/understanding-the-promise-type">Customising Co_Await</a></h2>
          <ul>
            <span class="fragment"><li>The <code>await_transform</code> method:</li></span>
            <span class="fragment"><ul><li>Defined in the <code>promise_type</code></li></ul></span>
            <span class="fragment"><ul><li>Enables types that are not awaitable</li></ul></span>
            <span class="fragment"><ul><li>Disables <code>co_await</code> on certain types</li></ul></span>
            <span class="fragment"><ul><li>Modify the behaviour of awaitable values</li></ul></span>
            <span class="fragment"><li>Also possible to customise <code>co_yield</code></li></span>
            <span class="fragment"><li>See Lewis Baker's excellent <a href="https://lewissbaker.github.io/2018/09/05/understanding-the-promise-type">Blog Post</a> for details</li></span>
          </ul>
        </section>

        <section>
          <h2><a href="https://en.cppreference.com/w/cpp/coroutine/coroutine_handle">Coroutine Handles</a></h2>
          <ul>
            <span class="fragment"><li>Handle to a coroutine frame on the heap</li></span>
            <span class="fragment"><li>Means through which coroutines are resumed</li></span>
            <span class="fragment"><li>Also provide access to the promise type</li></span>
            <span class="fragment"><li>Non-owning - have to be destroyed explicitly</li></span>
            <span class="fragment"><ul><li>Often through RAII in the coroutine return type</li></ul></span>
          </ul>
          <aside class="notes">
            Bit like a C pointer
          </aside>
        </section>
      </section>

        <!--

          Empirical study

          How do we study Coroutines Empirically?

          Coroutine example - Boost.beast
            Synchronous, Asycnhronous, Boost.Coroutine2 and awaitables
            apache bench

          Give data

            perf

        -->

        <!--

          Section on 'the future'

          P2502
          libunifex
          Std::exec
          Conclusions
          Questions

        -->

      <section>

        <section>
          <h2>Questions?</h2>
          <p><p>
          <a href="http://www.james-pascoe.com">http://www.james-pascoe.com</a><br>
          <a href="mailto:james@james-pascoe.com">james@james-pascoe.com</a><p>

          <a href="http://jamespascoe.github.io/accu2023">http://jamespascoe.github.io/accu2023</a><br>
          <a href="https://github.com/jamespascoe/accu2023-example-code.git"><font size="6">https://github.com/jamespascoe/accu2023-example-code.git</font></a>
        </section>

<!--
  Bristol and Bath Meetup
-->

        </section>
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script src="plugin/menu/menu.js"></script>
    <script src="plugin/chart/Chart.min.js"></script>
    <script src="plugin/chart/plugin.js"></script>
    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      Reveal.initialize({
        hash: true,
        controls: true,
        totalTime: 5400,
        hideInactiveCursor: true,
        hideCursorTime: 2000,
        hideAddressBar: true,
        preloadIframes: true,
        progress: false,
        touch: true,
        keyboard: {
          67: () => { /* Keycode for the letter 'c' i.e. 'controls' */
            var currentSlide = Reveal.getCurrentSlide();
            var currentVideo = currentSlide.getElementsByTagName('video')[0];
            if (currentVideo) {
              /* Toggle video controls on/off */
              currentVideo.controls = !currentVideo.controls
            }
          },
          32: () => { /* Keycode for spacebar */
            var currentSlide = Reveal.getCurrentSlide();
            var currentVideo = currentSlide.getElementsByTagName('video')[0];
            if (currentVideo) {
              /* Pause/resume video when the spacebar is pressed */
              if (currentVideo.paused == true) currentVideo.play();
              else currentVideo.pause();
            }
            else {
              /* Advance to next slide if no video (default Reveal behaviour) */
              Reveal.next();
            }
          }
        },
        chart: {
          defaults: {
            global: {
              title: { fontColor: "#FFF" },
              legend: {
                position: "bottom",
                labels: { fontColor: "#FFF" },
              },
              tooltips: {
                labels: { fontColor: "#FFF" },
              },
            },
            scale: {
              scaleLabel: { fontColor: "#FFF" },
              gridLines: { color: "#FFF", zeroLineColor: "#FFF" },
              ticks: { fontColor: "#FFF" },
            }
          },
          bar: { backgroundColor: [ "rgba(20,220,220,.8)" , "rgba(220,120,120,.8)", "rgba(20,120,220,.8)", "rgba(255, 159, 64, .8)","rgba(255, 205, 86, .8)", "rgba(153, 102, 255, .8)" ]},
        },
        menu: {
          themes: true,
          delayInit: true
        },
        pdfSeparateFragments: false,
        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealMenu, RevealChart ]
      });

      Reveal.addEventListener('hideControls', function() {
        Reveal.configure({controls: false});
      }, false );

      Reveal.addEventListener('slidechanged', function() {
        /* Ensure that the Reveal controls and Menu are available on
         * all slides other than the 'Title-Slide'.
         */
        slide_id = Reveal.getCurrentSlide().getAttribute("id");

        if (slide_id !== "Title-Slide") {
          config = Reveal.getConfig();
          if (config["controls"] !== true) {
            Reveal.configure({controls: true});
          }

          menu = Reveal.getPlugin("menu");
          if (!menu.isMenuInitialised()) {
            menu.initialiseMenu();
          }
        }
      }, false );

      Reveal.addEventListener('increasePlaybackSpeed', function() {
        var currentSlide = Reveal.getCurrentSlide();
        var currentVideo = currentSlide.getElementsByTagName('video')[0];
        if (currentVideo) {
          currentVideo.playbackRate = 2.0;
        }
      }, false );
   </script>
  </body>
</html>
