export function toPos(range){return{start:new CodeMirror.Pos(range.startLine,range.startColumn),end:new CodeMirror.Pos(range.endLine,range.endColumn)};}
export function toRange(start,end){return new TextUtils.TextRange(start.line,start.ch,end.line,end.ch);}
export function changeObjectToEditOperation(changeObject){const oldRange=toRange(changeObject.from,changeObject.to);const newRange=oldRange.clone();const linesAdded=changeObject.text.length;if(linesAdded===0){newRange.endLine=newRange.startLine;newRange.endColumn=newRange.startColumn;}else if(linesAdded===1){newRange.endLine=newRange.startLine;newRange.endColumn=newRange.startColumn+changeObject.text[0].length;}else{newRange.endLine=newRange.startLine+linesAdded-1;newRange.endColumn=changeObject.text[linesAdded-1].length;}
return{oldRange:oldRange,newRange:newRange};}
export function pullLines(codeMirror,linesCount){const lines=[];codeMirror.eachLine(0,linesCount,onLineHandle);return lines;function onLineHandle(lineHandle){lines.push(lineHandle.text);}}
export class TokenizerFactory{createTokenizer(mimeType){const mode=CodeMirror.getMode({indentUnit:2},mimeType);const state=CodeMirror.startState(mode);function tokenize(line,callback){const stream=new CodeMirror.StringStream(line);while(!stream.eol()){const style=mode.token(stream,state);const value=stream.current();callback(value,style,stream.start,stream.start+value.length);stream.start=stream.pos;}}
return tokenize;}}
self.TextEditor=self.TextEditor||{};TextEditor=TextEditor||{};TextEditor.CodeMirrorUtils={};TextEditor.CodeMirrorUtils.toPos=toPos;TextEditor.CodeMirrorUtils.toRange=toRange;TextEditor.CodeMirrorUtils.changeObjectToEditOperation=changeObjectToEditOperation;TextEditor.CodeMirrorUtils.pullLines=pullLines;TextEditor.CodeMirrorUtils.TokenizerFactory=TokenizerFactory;